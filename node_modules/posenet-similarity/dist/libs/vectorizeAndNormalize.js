"use strict";
exports.__esModule = true;
exports.L2Normalization = exports.scaleAndTranslate = exports.convertPoseToVectors = exports.vectorizeAndNormalize = void 0;
function vectorizeAndNormalize(pose, options) {
    var _a = convertPoseToVectors(pose, options.customWeight), vectorPoseXY = _a[0], vecotPoseTransform = _a[1], vectorPoseConfidences = _a[2];
    vectorPoseXY = scaleAndTranslate(vectorPoseXY, vecotPoseTransform);
    vectorPoseXY = L2Normalization(vectorPoseXY);
    return [
        vectorPoseXY,
        vectorPoseConfidences
    ];
}
exports.vectorizeAndNormalize = vectorizeAndNormalize;
/**
 * Covert the pose to a set of vectors
 *
 * @param pose The pose object to be converted.
 * @param weightOption The options to manipulate pose scores
 *
 * @return An array of vectors which stand for
 * [0] = The vector of pose keypoints x, y.
 *          [x1, y1, x2, y2, ... , x17, y17]
 * [1] = The values to translate and scale pose keypoints x, y vector.
 *          [translateX, translateY, scaler]
 * [2] = The scores of pose keypoints and the sum of them
 *          [score1, score2, ..., score17, sumOfScores]
 *          Will be used for the weightedDistance strategy
 */
function convertPoseToVectors(pose, weightOption) {
    var vectorPoseXY = [];
    var translateX = Number.POSITIVE_INFINITY;
    var translateY = Number.POSITIVE_INFINITY;
    var scaler = Number.NEGATIVE_INFINITY;
    var vectorScoresSum = 0;
    var vectorScores = [];
    // get weightOption if exists
    var mode, scores;
    if (weightOption) {
        mode = weightOption.mode;
        if (!mode || typeof mode !== 'string')
            throw new TypeError("[Bad customWeight option] A mode must be specified and should be either 'multiply', 'replace' or 'add'.");
        scores = weightOption.scores;
        if (typeof scores !== 'object' && !Array.isArray(scores))
            throw new TypeError("[Bad customWeight option] scores must be Object or Number[].\n      Please refer the document https://github.com/freshsomebody/posenet-similarity to set it correctly.");
    }
    pose.keypoints.forEach(function (point, index) {
        var x = point.position.x;
        var y = point.position.y;
        vectorPoseXY.push(x, y);
        translateX = Math.min(translateX, x);
        translateY = Math.min(translateY, y);
        scaler = Math.max(scaler, Math.max(x, y));
        var score = point.score;
        // modify original score according to the weightOption
        if (mode && scores) {
            var scoreModifier = false;
            // try to get scores from the weightOption
            if (scores[point.part] || scores[point.part] === 0)
                scoreModifier = scores[point.part];
            if (scores[index] || scores[index] === 0)
                scoreModifier = scores[index];
            // manipulate the original score
            if ((scoreModifier || scoreModifier === 0) && typeof scoreModifier === 'number') {
                switch (mode) {
                    case 'multiply':
                        score *= scoreModifier;
                        break;
                    case 'replace':
                        score = scoreModifier;
                        break;
                    case 'add':
                        score += scoreModifier;
                        break;
                    default:
                        throw new Error("[Bad customWeight option] A mode must be specified and should be either 'multiply', 'replace' or 'add'");
                }
            }
        }
        vectorScoresSum += score;
        vectorScores.push(score);
    });
    vectorScores.push(vectorScoresSum);
    return [
        vectorPoseXY,
        [translateX / scaler, translateY / scaler, scaler],
        vectorScores
    ];
}
exports.convertPoseToVectors = convertPoseToVectors;
/**
 * Scale and translate a pose to size 1*1
 *
 * @param vectorPoseXY The vector of pose keypoints x, y
 *        [x1, y1, x2, y2, ... , x17, y17]
 * @param transformValues The values to translate and scale pose keypoints x, y vector
 *        [translateX, translateY, scaler]
 *
 * @return An scaled and translated pose keypoints x, y vector in size 1*1
 *          [x1, y1, x2, y2, ... , x17, y17]
 */
function scaleAndTranslate(vectorPoseXY, transformValues) {
    var transX = transformValues[0], transY = transformValues[1], scaler = transformValues[2];
    return vectorPoseXY.map(function (position, index) {
        return (index % 2 === 0 ?
            position / scaler - transX :
            position / scaler - transY);
    });
}
exports.scaleAndTranslate = scaleAndTranslate;
/**
 * L2 nomalize a pose
 *
 * @param vectorPoseXY The vector of pose keypoints x, y
 *        [x1, y1, x2, y2, ... , x17, y17]
 *
 * @return An L2 normalized pose keypoints x, y vector in size 1*1
 *          [x1, y1, x2, y2, ... , x17, y17]
 */
function L2Normalization(vectorPoseXY) {
    var absVectorPoseXY = 0;
    vectorPoseXY.forEach(function (position) {
        absVectorPoseXY += Math.pow(position, 2);
    });
    absVectorPoseXY = Math.sqrt(absVectorPoseXY);
    return vectorPoseXY.map(function (position) {
        return position / absVectorPoseXY;
    });
}
exports.L2Normalization = L2Normalization;
