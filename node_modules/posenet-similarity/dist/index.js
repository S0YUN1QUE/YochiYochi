"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
exports.__esModule = true;
exports.poseSimilarity = void 0;
var vectorizeAndNormalize_1 = require("./libs/vectorizeAndNormalize");
var strategies_1 = require("./libs/strategies");
function poseSimilarity(pose1, pose2, overridenOptions) {
    // check inputted poses
    if (!pose1 || !pose1.keypoints ||
        !pose2 || !pose2.keypoints) {
        throw new Error('[Bad pose parameters] Please check your pose objects again.');
    }
    if (pose1.keypoints.length === 0 || pose2.keypoints.length === 0) {
        throw new Error('[Bad pose parameters] Found pose object(s) with empty keypoint.');
    }
    if (pose1.keypoints.length !== pose2.keypoints.length) {
        throw new Error('[Bad pose parameters] The keypoint lengths of the two pose objects are not the same.');
    }
    // merge options
    var defaultOptions = {
        strategy: 'weightedDistance'
    };
    var options = Object.assign({}, defaultOptions, overridenOptions);
    var _a = vectorizeAndNormalize_1.vectorizeAndNormalize(pose1, options), vectorPose1XY = _a[0], vectorPose1Scores = _a[1];
    var vectorPose2XY = vectorizeAndNormalize_1.vectorizeAndNormalize(pose2, options)[0];
    // execute strategy
    // if strategy is given by the string form
    if (typeof options.strategy === 'string') {
        switch (options.strategy) {
            case 'cosineSimilarity':
                return strategies_1.cosineSimilarity(vectorPose1XY, vectorPose2XY);
            case 'cosineDistance':
                return strategies_1.cosineDistanceMatching(vectorPose1XY, vectorPose2XY);
            case 'weightedDistance':
                return strategies_1.weightedDistanceMatching(vectorPose1XY, vectorPose2XY, vectorPose1Scores);
            default:
                throw new Error("[Bad strategy option] It should be either 'cosineSimilarity', 'cosineDistance' or 'weightedDistance' (default).");
        }
        // if strategy is given by a custom function
    }
    else if (typeof options.strategy === 'function') {
        return options.strategy(vectorPose1XY, vectorPose2XY, vectorPose1Scores);
    }
    else {
        throw new TypeError("[Bad strategy option] It only accepts string or function types of values.");
    }
}
exports.poseSimilarity = poseSimilarity;
var vectorizeAndNormalize_2 = require("./libs/vectorizeAndNormalize");
__createBinding(exports, vectorizeAndNormalize_2, "vectorizeAndNormalize");
var strategies_2 = require("./libs/strategies");
__createBinding(exports, strategies_2, "cosineSimilarity");
__createBinding(exports, strategies_2, "cosineDistanceMatching");
__createBinding(exports, strategies_2, "weightedDistanceMatching");
